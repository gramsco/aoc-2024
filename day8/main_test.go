package main

import (
	"fmt"
	"testing"
)

func Test(t *testing.T) {
	puzzle := `............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............`

	result, height, width := parsePuzzle(puzzle)

	if height != 12 || width != 12 {
		t.Fatalf("Expected height 12 (not %d) and width 12 (not %d)\n, ", height, width)
	}

	allZeros := []Vector{{1, 8}, {2, 5}, {3, 7}, {4, 4}}

	for i, zero := range allZeros {
		if result['0'][i] != zero {
			t.Fatalf(
				"Expected (%d,%d), received (%d,%d)",
				zero.y,
				zero.x,
				result['0'][i].y,
				result['0'][i].x,
			)
		}
	}
}

func TestComputeLocationsWithTwoPoints(t *testing.T) {

	locations := []Vector{{3, 4}, {5, 5}}

	result := computeFrequencyLocation(locations, 12, 12)
	fmt.Println(result)

	first := result[0]
	if first != (Vector{1, 3}) {
		t.Fatalf("Error! %d %d", first.y, first.x)
	}
}

func TestPart1(t *testing.T) {
	puzzle := `............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............`

	result := part1(puzzle)
	if result != 14 {
		t.Fatalf("Expected 14, received %d", result)
	}
}

func TestPart2(t *testing.T) {
	puzzle := `............
........0...
.....0......
.......0....
....0.......
......A.....
............
............
........A...
.........A..
............
............`

	result := part2(puzzle)
	if result != 34 {
		t.Fatalf("Expected 34, received %d", result)
	}
}
